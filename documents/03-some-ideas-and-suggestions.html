<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Some Ideas And Suggestions</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="03-some-ideas-and-suggestions_files/libs/clipboard/clipboard.min.js"></script>
<script src="03-some-ideas-and-suggestions_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="03-some-ideas-and-suggestions_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="03-some-ideas-and-suggestions_files/libs/quarto-html/popper.min.js"></script>
<script src="03-some-ideas-and-suggestions_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="03-some-ideas-and-suggestions_files/libs/quarto-html/anchor.min.js"></script>
<link href="03-some-ideas-and-suggestions_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="03-some-ideas-and-suggestions_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="03-some-ideas-and-suggestions_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="03-some-ideas-and-suggestions_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="03-some-ideas-and-suggestions_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Some Ideas And Suggestions</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div id="be32a09e" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>sys.path.append(<span class="st">'..'</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> cryptext.cicada <span class="im">import</span> liberprimus <span class="im">as</span> lp, gematriaprimus <span class="im">as</span> gp, futhorc</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> cryptext.analytics <span class="im">import</span> ioc, expected_ioc, diff_text, crosstext_ioc</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> helperfunctions <span class="im">import</span> find_phrase_groups, find_phrase_groups_strict, pgroups_to_ppairs, count_rune_matches</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>This document serves as a collection of possible paths to pursue in further attempts at solving the Liber Primus. Any of the following ideas may be tackled independently of each other, and each may help further push the solving effort in a meaningful way.</p>
<section id="more-information-on-autokey-component" class="level2">
<h2 class="anchored" data-anchor-id="more-information-on-autokey-component">More Information On Autokey Component</h2>
<p>It has been established that the match rate of the first phrase letter among phrase pairs is higher than other letters. The mechanism we used to explain this is a backwards autokey. It is possible that this assumption is wrong and the match rate is explained by some other mechanism, but even if we assume it is true, it leaves many (including some quite fundamental) questions unanswered.</p>
<p>One of these questions is: while we see the match rate increase only for the first letter of a word, does the autokey also apply to other letters (likely with another layer of encryption on top)? Or is encryption of other letters independent of this autokey component? A similar question could be applied to the first letter itself: would some autokey be enough to obfuscate the ciphertext of even the first letter to this extent, or is some other cipher used on top of it?</p>
<section id="constant-or-word-based-offset" class="level3">
<h3 class="anchored" data-anchor-id="constant-or-word-based-offset">Constant or Word-based Offset</h3>
<p>Another question is: if the cipher is word-aware, is the autokey also word-aware (e.g.&nbsp;that the dependency is always in the next word, or perhaps even computed from the entire next word), or is it a traditional constant offset autokey, which may reach into the next word, the current one or even the word after the next? This could in theory be tested by plotting match rates by total rune length of a phrase, and comparing the match rates - if the autokey is with a constant offset, then we should expect a sharp jump in the match rate once the phrase length reaches the offset. The Moebius section somewhat appears to conform to this, with the expected offset being about 9 runes:</p>
<div id="9f1dd057" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>fig_title <span class="op">=</span> <span class="st">'Match rate among 2-word phrase pairs</span><span class="ch">\n</span><span class="st">grouped by phrase length (Moebius only)'</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>pgroups <span class="op">=</span> find_phrase_groups_strict(lp.section_moebius(), <span class="dv">2</span>, <span class="dv">5</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>plot_x <span class="op">=</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">14</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>plot_y_phrase <span class="op">=</span> []</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> word_length <span class="kw">in</span> plot_x:</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    fp <span class="op">=</span> [p <span class="cf">for</span> p <span class="kw">in</span> pgroups <span class="cf">if</span> <span class="bu">sum</span>(<span class="bu">len</span>(w) <span class="cf">for</span> w <span class="kw">in</span> p[<span class="dv">0</span>].words) <span class="op">==</span> word_length]</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    stats <span class="op">=</span> count_rune_matches(fp)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    p,pm,a,m,wa,wm,fw,fwm <span class="op">=</span> stats.pairs, stats.first_word_nth_rune_matches[<span class="dv">0</span>], stats.runes, stats.rune_matches, stats.words, stats.word_begin_matches, stats.first_word_runes, stats.first_word_rune_matches</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    plot_y_phrase.append(pm<span class="op">/</span>p <span class="cf">if</span> p <span class="op">&gt;=</span> <span class="dv">5</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>ax.plot(plot_x, plot_y_phrase, label<span class="op">=</span><span class="st">'First word start'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>ax.axhline(<span class="dv">1</span><span class="op">/</span><span class="dv">29</span>, color<span class="op">=</span><span class="st">'#999999aa'</span>, label<span class="op">=</span><span class="st">'Expected'</span>)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_label_text(<span class="st">'Phrase length (runes)'</span>)</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>ax.yaxis.set_label_text(<span class="st">'Match rate'</span>)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>ax.set_title(fig_title)</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="03-some-ideas-and-suggestions_files/figure-html/cell-3-output-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
</div>
</div>
<p>However, when looking at the other sections, the results are less conclusive, which might mean that it does not hold for Moebius either (<strong>note:</strong> I am only including sections with higher-than-expected phrase start match rate, i.e.&nbsp;not wing-tree onward):</p>
<div id="7a77b4b3" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>fig_title <span class="op">=</span> <span class="st">'Match rate among 2-word phrase pairs</span><span class="ch">\n</span><span class="st">grouped by phrase length (by section)'</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> section <span class="kw">in</span> lp.load_unsolved().sections()[:<span class="op">-</span><span class="dv">3</span>]:</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    pgroups <span class="op">=</span> find_phrase_groups_strict(section, <span class="dv">2</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    plot_x <span class="op">=</span> <span class="bu">range</span>(<span class="dv">6</span>, <span class="dv">17</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    plot_y <span class="op">=</span> []</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> phrase_rune_length <span class="kw">in</span> plot_x:</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        fp <span class="op">=</span> [p <span class="cf">for</span> p <span class="kw">in</span> pgroups <span class="cf">if</span> <span class="bu">sum</span>(<span class="bu">len</span>(w) <span class="cf">for</span> w <span class="kw">in</span> p[<span class="dv">0</span>].words) <span class="op">==</span> phrase_rune_length]</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        stats <span class="op">=</span> count_rune_matches(fp)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        p,pm,a,m,wa,wm <span class="op">=</span> stats.pairs, stats.first_word_nth_rune_matches[<span class="dv">0</span>], stats.runes, stats.rune_matches, stats.words, stats.word_begin_matches</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        plot_y.append(pm<span class="op">/</span>p <span class="cf">if</span> p <span class="op">&gt;=</span> <span class="dv">5</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    ax.plot(plot_x, plot_y, label<span class="op">=</span>section.name().replace(<span class="st">'Spiral '</span>, <span class="st">'Sp. '</span>), marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>ax.axhline(<span class="dv">1</span><span class="op">/</span><span class="dv">29</span>, color<span class="op">=</span><span class="st">'#999999aa'</span>, label<span class="op">=</span><span class="st">'Expected'</span>)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_label_text(<span class="st">'Phrase length (runes)'</span>)</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>ax.yaxis.set_label_text(<span class="st">'Match rate'</span>)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>ax.set_title(fig_title)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="03-some-ideas-and-suggestions_files/figure-html/cell-4-output-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="other-ways-to-group-phrase-pairs" class="level3">
<h3 class="anchored" data-anchor-id="other-ways-to-group-phrase-pairs">Other Ways To Group Phrase Pairs</h3>
<p>As a side-note, it is also possible to divide the 2-word phrase pairs by other statistics than phrase length; perhaps we might be able to spot some more patterns. The two main additional groupings are by the length of the first word, or by the second word; both have advantages and disadvantages. Grouping by first word seems less correlated and more noisy overall, but when looked at by individual sections, it reaches greater peaks. Grouping by second word on the other hand produces a mostly flat graph, except for two high points, and there are some notable peaks in other areas than just first word start (although more on that later).</p>
<p>Regardless, I unfortunately was not able to find any consistent order in these groupings that I could explain.</p>
<div id="f99fb4a4" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>fig_title <span class="op">=</span> <span class="st">'Match rate among 2-word phrase pairs</span><span class="ch">\n</span><span class="st">grouped by second word length (unsolved sections up to Mayfly)'</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>pgroups <span class="op">=</span> []</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> s <span class="kw">in</span> lp.load_unsolved().sections()[:<span class="op">-</span><span class="dv">3</span>]:</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    pgroups <span class="op">+=</span> find_phrase_groups_strict(s, <span class="dv">2</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>plot_x <span class="op">=</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">14</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>plot_y_total <span class="op">=</span> []</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>plot_y_word <span class="op">=</span> []</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>plot_y_phrase <span class="op">=</span> []</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co"># plot_y_next_matches = []</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> word_length <span class="kw">in</span> plot_x:</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    fp <span class="op">=</span> [p <span class="cf">for</span> p <span class="kw">in</span> pgroups <span class="cf">if</span> <span class="bu">len</span>(p[<span class="dv">0</span>].words[<span class="dv">1</span>]) <span class="op">==</span> word_length]</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># fp = pgroups_to_ppairs(fp)</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># plot_y_next_matches.append(</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">#     sum(</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">#         len(p[0].word_after) == len(p[1].word_after)</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">#         for p in fp</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">#         if p[0].word_after is not None and p[1].word_after is not None</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">#     ) / (len(fp) or 1)</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># )</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    stats <span class="op">=</span> count_rune_matches(fp)</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    p,pm,a,m,wa,wm,fw,fwm <span class="op">=</span> stats.pairs, stats.first_word_nth_rune_matches[<span class="dv">0</span>], stats.runes, stats.rune_matches, stats.words, stats.word_begin_matches, stats.first_word_runes, stats.first_word_rune_matches</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    plot_y_total.append(m<span class="op">/</span>a <span class="cf">if</span> a <span class="op">&gt;=</span> <span class="dv">5</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    plot_y_word.append((wm <span class="op">-</span> pm)<span class="op">/</span>(wa <span class="op">-</span> p) <span class="cf">if</span> (wa <span class="op">-</span> p) <span class="op">&gt;=</span> <span class="dv">5</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    plot_y_phrase.append(pm<span class="op">/</span>p <span class="cf">if</span> p <span class="op">&gt;=</span> <span class="dv">5</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>ax.plot(plot_x, plot_y_total, label<span class="op">=</span><span class="st">'Total'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>ax.plot(plot_x, plot_y_word, label<span class="op">=</span><span class="st">'Second word start'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>ax.plot(plot_x, plot_y_phrase, label<span class="op">=</span><span class="st">'First word start'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a><span class="co"># ax.plot(plot_x, plot_y_next_matches, label='Next word length match fraction', marker='.')</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>ax.axhline(<span class="dv">1</span><span class="op">/</span><span class="dv">29</span>, color<span class="op">=</span><span class="st">'#999999aa'</span>, label<span class="op">=</span><span class="st">'Expected'</span>)</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_label_text(<span class="st">'Second word length'</span>)</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>ax.yaxis.set_label_text(<span class="st">'Match rate'</span>)</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>ax.set_title(fig_title)</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="03-some-ideas-and-suggestions_files/figure-html/cell-5-output-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The rest of the groupings (along with other experiments related to the autokey component) was moved to the <a href="./99-fruitless-experiments.html">Fruitless Experiments</a> document to save space.</p>
</section>
</section>
<section id="encryption-of-the-remaining-letters" class="level2">
<h2 class="anchored" data-anchor-id="encryption-of-the-remaining-letters">Encryption Of The Remaining Letters</h2>
<p>So far I have only talked about first letters of words or phrases, but the remaining letters are just as important, and if the autokey component dependency for first letters of words is not directed at the next word’s first letter (which it most likely isn’t), then knowing the remaining letters is neccessary to even work with the first letters. So what can be inferred from the ciphertext?</p>
<section id="second-phrase-letter-match-rate" class="level3">
<h3 class="anchored" data-anchor-id="second-phrase-letter-match-rate">Second Phrase Letter Match Rate</h3>
<p>If we plot the match rate of the second letter in the first phrase’s word alongside other statistics, we find out that the match rate is higher than the total match rate (although admittedly not that much). On first impression, that looks good, because it shows at least some predictability:</p>
<div id="eb0f435b" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>fig_title <span class="op">=</span> <span class="st">'Rune matches among phrase pairs</span><span class="ch">\n</span><span class="st">(unsolved sections up to Mayfly)'</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> [<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>Yall, Yword, Yphrase, Ysecond <span class="op">=</span> [], [], [], []</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> min_phrase_length <span class="kw">in</span> X:</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    pgroups <span class="op">=</span> []</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s <span class="kw">in</span> lp.load_unsolved().sections()[:<span class="op">-</span><span class="dv">3</span>]:</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        pgroups <span class="op">+=</span> find_phrase_groups(s, min_phrase_length)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    stats <span class="op">=</span> count_rune_matches(pgroups)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    p,pm,a,m,wa,wm <span class="op">=</span> stats.pairs, stats.first_word_nth_rune_matches[<span class="dv">0</span>], stats.runes, stats.rune_matches, stats.words, stats.word_begin_matches</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    sa, sm <span class="op">=</span> stats.first_word_of_length_above[<span class="dv">1</span>], stats.first_word_nth_rune_matches[<span class="dv">1</span>]</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    Yall.append(m <span class="op">/</span> a <span class="cf">if</span> a <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    Yword.append(wm <span class="op">/</span> wa <span class="cf">if</span> wa <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    Yphrase.append(pm <span class="op">/</span> p <span class="cf">if</span> p <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    Ysecond.append(sm <span class="op">/</span> sa <span class="cf">if</span> sa <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>ax.plot(X, Yall, label<span class="op">=</span><span class="st">'Total match rate'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>ax.plot(X, Yword, label<span class="op">=</span><span class="st">'Word-start m. r.'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>ax.plot(X, Yphrase, label<span class="op">=</span><span class="st">'Phrase-start m. r.'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>ax.plot(X, Ysecond, label<span class="op">=</span><span class="st">'Phrase-second-letter m. r.'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>ax.axhline(<span class="dv">1</span><span class="op">/</span><span class="dv">29</span>, color<span class="op">=</span><span class="st">'#999999aa'</span>, label<span class="op">=</span><span class="st">'Expected m. r.'</span>)</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>ax.set_ylim(bottom<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>plt.gca().invert_xaxis()</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>ax.set_xticks(X)</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_label_text(<span class="st">'Minimum phrase length in words'</span>)</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>ax.yaxis.set_label_text(<span class="st">'Match rate'</span>)</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>ax.set_title(fig_title)</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="03-some-ideas-and-suggestions_files/figure-html/cell-6-output-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
</div>
</div>
<p>When looked at more closely, by section, it looks like different sections once again show different behavior, with Spirals, Branches, and Mayfly in particular showing a spike in the second phrase letter match rate in 3-word phrases, while Moebius and Crosses behaving more evenly.</p>
<div id="8baa0772" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>fig_title <span class="op">=</span> <span class="st">'Rune matches among phrase pairs</span><span class="ch">\n</span><span class="st">(Spirals, Branches, and Mayfly)'</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Discovered: 2025-06-22</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> [<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>]</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>Yall, Yword, Yphrase, Ysecond <span class="op">=</span> [], [], [], []</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> min_phrase_length <span class="kw">in</span> X:</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    pgroups <span class="op">=</span> []</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s <span class="kw">in</span> [ lp.section_spirals(), lp.section_branches(), lp.section_mayfly() ]:</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        pgroups <span class="op">+=</span> find_phrase_groups_strict(s, min_phrase_length)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    stats <span class="op">=</span> count_rune_matches(pgroups)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    p,pm,a,m,wa,wm <span class="op">=</span> stats.pairs, stats.first_word_nth_rune_matches[<span class="dv">0</span>], stats.runes, stats.rune_matches, stats.words, stats.word_begin_matches</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    sa, sm <span class="op">=</span> stats.first_word_of_length_above[<span class="dv">1</span>], stats.first_word_nth_rune_matches[<span class="dv">1</span>]</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    Yall.append(m <span class="op">/</span> a <span class="cf">if</span> a <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    Yword.append(wm <span class="op">/</span> wa <span class="cf">if</span> wa <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    Yphrase.append(pm <span class="op">/</span> p <span class="cf">if</span> p <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    Ysecond.append(sm <span class="op">/</span> sa <span class="cf">if</span> sa <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>ax.plot(X, Yall, label<span class="op">=</span><span class="st">'Total match rate'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>ax.plot(X, Yword, label<span class="op">=</span><span class="st">'Word-start m. r.'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>ax.plot(X, Yphrase, label<span class="op">=</span><span class="st">'Phrase-start m. r.'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>ax.plot(X, Ysecond, label<span class="op">=</span><span class="st">'Phrase-second-letter m. r.'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>ax.axhline(<span class="dv">1</span><span class="op">/</span><span class="dv">29</span>, color<span class="op">=</span><span class="st">'#999999aa'</span>, label<span class="op">=</span><span class="st">'Expected m. r.'</span>)</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>ax.set_ylim(bottom<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>plt.gca().invert_xaxis()</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>ax.set_xticks(X)</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_label_text(<span class="st">'Minimum phrase length in words'</span>)</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>ax.yaxis.set_label_text(<span class="st">'Match rate'</span>)</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>ax.set_title(fig_title)</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="03-some-ideas-and-suggestions_files/figure-html/cell-7-output-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
</div>
</div>
<p>You can try to search for other letters than just the second, and it turns out, the 5th letter has an even more increased match rate than the first in Spirals, Branches, and Mayfly at 3-word phrases. At this point, this feels like a major clue (now only to know what it’s saying).</p>
<div id="ec26f5ac" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>fig_title <span class="op">=</span> <span class="st">'Rune matches among phrase pairs</span><span class="ch">\n</span><span class="st">(Spirals, Branches, and Mayfly)'</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Discovered: 2025-06-22</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> [<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>]</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>Yall, Yword, Yphrase, Ysecond <span class="op">=</span> [], [], [], []</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> min_phrase_length <span class="kw">in</span> X:</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    pgroups <span class="op">=</span> []</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s <span class="kw">in</span> [ lp.section_spirals(), lp.section_branches(), lp.section_mayfly() ]:</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        pgroups <span class="op">+=</span> find_phrase_groups_strict(s, min_phrase_length)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    stats <span class="op">=</span> count_rune_matches(pgroups)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    p,pm,a,m,wa,wm <span class="op">=</span> stats.pairs, stats.first_word_nth_rune_matches[<span class="dv">0</span>], stats.runes, stats.rune_matches, stats.words, stats.word_begin_matches</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    sa, sm <span class="op">=</span> stats.first_word_of_length_above[<span class="dv">4</span>], stats.first_word_nth_rune_matches[<span class="dv">4</span>]</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    Yall.append(m <span class="op">/</span> a <span class="cf">if</span> a <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    Yword.append(wm <span class="op">/</span> wa <span class="cf">if</span> wa <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    Yphrase.append(pm <span class="op">/</span> p <span class="cf">if</span> p <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    Ysecond.append(sm <span class="op">/</span> sa <span class="cf">if</span> sa <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'</span><span class="sc">{</span>min_phrase_length<span class="sc">}</span><span class="ss"> words : </span><span class="sc">{</span>sm<span class="sc">}</span><span class="ss"> / </span><span class="sc">{</span>sa<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>ax.plot(X, Yall, label<span class="op">=</span><span class="st">'Total match rate'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>ax.plot(X, Yword, label<span class="op">=</span><span class="st">'Word-start m. r.'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>ax.plot(X, Yphrase, label<span class="op">=</span><span class="st">'Phrase-start m. r.'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>ax.plot(X, Ysecond, label<span class="op">=</span><span class="st">'Phrase-fifth-letter m. r.'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>ax.axhline(<span class="dv">1</span><span class="op">/</span><span class="dv">29</span>, color<span class="op">=</span><span class="st">'#999999aa'</span>, label<span class="op">=</span><span class="st">'Expected m. r.'</span>)</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>ax.set_ylim(bottom<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>plt.gca().invert_xaxis()</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>ax.set_xticks(X)</span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_label_text(<span class="st">'Minimum phrase length in words'</span>)</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>ax.yaxis.set_label_text(<span class="st">'Match rate'</span>)</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>ax.set_title(fig_title)</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>5 words : 0 / 1
4 words : 0 / 7
3 words : 7 / 74
2 words : 18 / 460</code></pre>
</div>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="03-some-ideas-and-suggestions_files/figure-html/cell-8-output-2.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="high-points-in-2-word-phrases" class="level3">
<h3 class="anchored" data-anchor-id="high-points-in-2-word-phrases">High Points In 2-Word Phrases</h3>
<p>Some special views of the ciphertext (in particular when matching 2-word phrases) show spikes in match rate of the phrase’s first word. Perhaps those could be exploited (e.g.&nbsp;with help of cribs). <em>How</em> to exploit it, though, I am not sure.</p>
<div id="4b0765c6" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>fig_title <span class="op">=</span> <span class="st">'Match rate among 2-word phrase pairs</span><span class="ch">\n</span><span class="st">grouped by second word length (unsolved sections up to Mayfly)'</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>pgroups <span class="op">=</span> []</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> s <span class="kw">in</span> lp.load_unsolved().sections()[:<span class="op">-</span><span class="dv">3</span>]:</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    pgroups <span class="op">+=</span> find_phrase_groups_strict(s, <span class="dv">2</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>plot_x <span class="op">=</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">14</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>plot_y_word <span class="op">=</span> []</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>plot_y_phrase <span class="op">=</span> []</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>plot_y_fw <span class="op">=</span> []</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>plot_y_sw <span class="op">=</span> []</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> word_length <span class="kw">in</span> plot_x:</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    fp <span class="op">=</span> [p <span class="cf">for</span> p <span class="kw">in</span> pgroups <span class="cf">if</span> <span class="bu">len</span>(p[<span class="dv">0</span>].words[<span class="dv">1</span>]) <span class="op">==</span> word_length]</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    stats <span class="op">=</span> count_rune_matches(fp)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    p,pm,a,m,wa,wm,fw,fwm <span class="op">=</span> stats.pairs, stats.first_word_nth_rune_matches[<span class="dv">0</span>], stats.runes, stats.rune_matches, stats.words, stats.word_begin_matches, stats.first_word_runes, stats.first_word_rune_matches</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    fwa <span class="op">=</span> <span class="bu">sum</span>(stats.first_word_of_length_above[<span class="dv">1</span>:])</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    fwm <span class="op">=</span> <span class="bu">sum</span>(stats.first_word_nth_rune_matches[<span class="dv">1</span>:])</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    swa, swm <span class="op">=</span> a <span class="op">-</span> p <span class="op">-</span> fwa, m <span class="op">-</span> pm <span class="op">-</span> fwm</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    plot_y_word.append((wm <span class="op">-</span> pm)<span class="op">/</span>(wa <span class="op">-</span> p) <span class="cf">if</span> (wa <span class="op">-</span> p) <span class="op">&gt;=</span> <span class="dv">5</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    plot_y_phrase.append(pm<span class="op">/</span>p <span class="cf">if</span> p <span class="op">&gt;=</span> <span class="dv">5</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>    plot_y_fw.append(fwm<span class="op">/</span>fwa <span class="cf">if</span> fwa <span class="op">&gt;=</span> <span class="dv">5</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    plot_y_sw.append(swm<span class="op">/</span>swa <span class="cf">if</span> swa <span class="op">&gt;=</span> <span class="dv">5</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>ax.plot(plot_x, plot_y_sw, label<span class="op">=</span><span class="st">'Second word total'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>ax.plot(plot_x, plot_y_word, label<span class="op">=</span><span class="st">'Second word start'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>ax.plot(plot_x, plot_y_phrase, label<span class="op">=</span><span class="st">'First word start'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>ax.plot(plot_x, plot_y_fw, label<span class="op">=</span><span class="st">'First word w/o. first letter'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>ax.axhline(<span class="dv">1</span><span class="op">/</span><span class="dv">29</span>, color<span class="op">=</span><span class="st">'#999999aa'</span>, label<span class="op">=</span><span class="st">'Expected'</span>)</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_label_text(<span class="st">'Second word length'</span>)</span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>ax.yaxis.set_label_text(<span class="st">'Match rate'</span>)</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>ax.set_title(fig_title)</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="03-some-ideas-and-suggestions_files/figure-html/cell-9-output-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="1eca4782" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>fig_title <span class="op">=</span> <span class="st">'Match rate among 2-word phrase pairs</span><span class="ch">\n</span><span class="st">grouped by second word length (Moebius section)'</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>pgroups <span class="op">=</span> find_phrase_groups_strict(lp.section_moebius(), <span class="dv">2</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>plot_x <span class="op">=</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">14</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>plot_y_word <span class="op">=</span> []</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>plot_y_phrase <span class="op">=</span> []</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>plot_y_fw <span class="op">=</span> []</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>plot_y_sw <span class="op">=</span> []</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> word_length <span class="kw">in</span> plot_x:</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    fp <span class="op">=</span> [p <span class="cf">for</span> p <span class="kw">in</span> pgroups <span class="cf">if</span> <span class="bu">len</span>(p[<span class="dv">0</span>].words[<span class="dv">1</span>]) <span class="op">==</span> word_length]</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    stats <span class="op">=</span> count_rune_matches(fp)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    p,pm,a,m,wa,wm,fw,fwm <span class="op">=</span> stats.pairs, stats.first_word_nth_rune_matches[<span class="dv">0</span>], stats.runes, stats.rune_matches, stats.words, stats.word_begin_matches, stats.first_word_runes, stats.first_word_rune_matches</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    fwa <span class="op">=</span> <span class="bu">sum</span>(stats.first_word_of_length_above[<span class="dv">1</span>:])</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    fwm <span class="op">=</span> <span class="bu">sum</span>(stats.first_word_nth_rune_matches[<span class="dv">1</span>:])</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    swa, swm <span class="op">=</span> a <span class="op">-</span> p <span class="op">-</span> fwa, m <span class="op">-</span> pm <span class="op">-</span> fwm</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    plot_y_word.append((wm <span class="op">-</span> pm)<span class="op">/</span>(wa <span class="op">-</span> p) <span class="cf">if</span> (wa <span class="op">-</span> p) <span class="op">&gt;=</span> <span class="dv">5</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>    plot_y_phrase.append(pm<span class="op">/</span>p <span class="cf">if</span> p <span class="op">&gt;=</span> <span class="dv">5</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>    plot_y_fw.append(fwm<span class="op">/</span>fwa <span class="cf">if</span> fwa <span class="op">&gt;=</span> <span class="dv">5</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    plot_y_sw.append(swm<span class="op">/</span>swa <span class="cf">if</span> swa <span class="op">&gt;=</span> <span class="dv">5</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>ax.plot(plot_x, plot_y_sw, label<span class="op">=</span><span class="st">'Second word total'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>ax.plot(plot_x, plot_y_word, label<span class="op">=</span><span class="st">'Second word start'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>ax.plot(plot_x, plot_y_phrase, label<span class="op">=</span><span class="st">'First word start'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>ax.plot(plot_x, plot_y_fw, label<span class="op">=</span><span class="st">'First word w/o. first letter'</span>, marker<span class="op">=</span><span class="st">'.'</span>)</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>ax.axhline(<span class="dv">1</span><span class="op">/</span><span class="dv">29</span>, color<span class="op">=</span><span class="st">'#999999aa'</span>, label<span class="op">=</span><span class="st">'Expected'</span>)</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_label_text(<span class="st">'Second word length'</span>)</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>ax.yaxis.set_label_text(<span class="st">'Match rate'</span>)</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>ax.set_title(fig_title)</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="03-some-ideas-and-suggestions_files/figure-html/cell-10-output-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="possible-mechanisms" class="level3">
<h3 class="anchored" data-anchor-id="possible-mechanisms">Possible Mechanisms</h3>
<p>So what could be the possible ways the second and later letters of words be encrypted? Unfortunately, the most I can manage at this point are very rough estimates, but let’s lay out a couple of ideas anyway (and then explain why they are probably wrong).</p>
<section id="autokey-with-different-offset" class="level4">
<h4 class="anchored" data-anchor-id="autokey-with-different-offset">Autokey With Different Offset</h4>
<p>The other letters may be dependent on other letters just like the first letter, but the offset is different, potentially (much?) larger. If the autokey is word-based instead of letter-based (with constant offset), then a large distance could easily be calculated (e.g.&nbsp;2 words after, 3 words, etc., perhaps even words before?) even through various skips due to <strong>f</strong> interruptors or rune doublets… oh right, low rune doublets. We haven’t even started on those.</p>
<p>This mechanism doesn’t require extra ciphers, and so could be considered <em>“simple”</em>, but it just doesn’t seem compatible with the data from the ciphertext. Phrase pairs aren’t as long as in the solved sections, but they are still up to 7 words, and by then, even with very long offsets, the plaintexts should be stabilized at least for a couple of letters. And if the autokey is word-based, then we might expect an increasing trend of matches with a long phrase pair (i.e.&nbsp;right to left first one letter equals, then two, etc.) but that is not what we see, therefore this method likely isn’t used.</p>
</section>
<section id="ciphertext-autokey" class="level4">
<h4 class="anchored" data-anchor-id="ciphertext-autokey">Ciphertext Autokey</h4>
<p>What if the letters are dependent on the immediately previous letter, just on its ciphertext? Well, since the match rate of the first letter is high, then we should expect a match in the first letter to be followed by a match in the next letter in 100% of cases. Therefore this is not a likely solution.</p>
<hr>
<p>I am not sure whether each letter after the first of a word has its own complicated encryption method, but if it does, even just solving the first three or so might be enough for the rest of the word to be guessable. If the difference is only between the first and other letters of words, then a single method should suffice for everything.</p>
</section>
</section>
</section>
<section id="independence-from-phrase-pairs" class="level2">
<h2 class="anchored" data-anchor-id="independence-from-phrase-pairs">Independence From Phrase Pairs</h2>
<p>Analyzing the ciphertext using phrase pairs has its advantages, as we can assume that the pairs’ plaintexts match more often than not, but it is also a limited view into the workings of the cipher, since the pairs only represent “random points” in the ciphertext, at which the state of the cipher and content of the plaintext are often hard to guess.</p>
<p>Another disadvantage is that, despite the entirety of ciphertext being large, phrase pairs are not always abundant, which leads to small datasets, which are much more prone to finding nonexistent patterns in.</p>
<p>Finding some order within the entire ciphertext would give solvers advantage when tackling any and all parts of the ciphertext (and flexibility to focus on what they find most promising), but unfortunately, even if some pattern is known to exist in phrase pairs, attempts at finding some equivalent in the entire ciphertext have so far all failed.</p>
</section>
<section id="general-properties" class="level2">
<h2 class="anchored" data-anchor-id="general-properties">General Properties</h2>
<p>Due to my <em>relative</em> success with matching phrase pairs, I think that, just like the solved ones, the unsolved sections do not include transposition in their encryption. I think if they did, then the match rate of phrase pairs would not be as good as it is. But then again… transposition would explain some properties even the autokey component hypothesis can’t, so maybe we should not rule it out just yet.</p>
<p>From various patterns in their ciphertexts (peak in phrase start match rate at 2-word phrases, peak in second letter match rate at 3-word phrases, peak in word-before start letter match rate at 3-word phrases), I would guess that <em>Spirals</em>, <em>Branches</em>, and <em>Mayfly</em> sections are likely encrypted with a single cipher, or at least the same kind of cipher.</p>
<p><em>Moebius</em> seems to behave the most nicely and has good amount of phrase pairs, along with being large, which should give solvers more room to collect data on. <em>Crosses</em> seem similar to Moebius, but due to their relatively low size, it is hard to spot similarities that are consistent.</p>
<p><em>Spiral Branches</em> retain some nice properties of Moebius (well, mostly just the higher word match rate), but otherwise they feel to me like they will be one of the harder sections to crack. I did not do any special analysis of the final paragraph at <code>44.jpg-45.jpg</code>, and I don’t think it will be any different, but it is possible.</p>
<p>And finally, I have no idea what <em>Wing-Tree</em> and <em>Cuneiform</em> are, and would probably focus on them the least at this point.</p>
</section>
<section id="some-matches" class="level2">
<h2 class="anchored" data-anchor-id="some-matches">Some Matches?</h2>
<p>Here are some cool matches I found. They are pretty much cherry-picked, so don’t be too eager to apply properties from here to the entire unsolved sections.</p>
<pre><code>@ BRANCHES

"ᚩᛁᛈ-ᛁᛄᛁᚩᛖ"  &lt;
"ᛚᛝᚢ-ᛉᛄᚠᛟᚢ"  &lt;&lt; (note the second-word matches as well)
"ᚩᛈᛗ-ᛖᛉᛡᛒᚹ" &lt;
"ᛚᚳᛄ-ᛉᚪᚾᛇᛉ"   &lt;&lt;


@ MOEBIUS

"ᛁᛞᛄ ᛖᛗᚱ ᚷᚪᚻᛠᛚᚷᚩ ᛉᚻ ᛡᛝ ᛞᚱᚹᚩᛈᛡ ᚣᚳᚦ"
"ᛁᚫᛟ ᛖᛗᚹ ᛖᛉᚦᛗᚪᛋᛉ ᛞᚦ ᛡᚢ ᛉᛗᚫᛋᚳᛖ ᚳᚫᛠ"


"ᚢᚳᚱᛡ-ᛖᚩᛁᚣᛄᛏᛡ" &lt;
"ᛇᛠᛄᛁ-ᛟᛄᛞᚢᚳᛝᚩ"  (interestingly, the ᚢᚳ bigram is also here, though offset... but there is not much reason to think this is anything but coincidence; especially due to different encryption of first and non-first letter in word)
"ᚢᚳᚱᚻ-ᛡᛟᛗᛠᛝᛄᚦ" &lt;

"ᚠᚣᚢᛁᚹ-ᛟᚪᚣᛁᛠᛄᚪ" &lt;
"ᛝᛚᛗᛠᛗ-ᚪᚱᛡᛗᛒᚩᚹ"
"ᚠᛝᚠᚱᚹ-ᛟᛒᛗᚷᛞᚾᛡ" &lt;
"ᚷᛄᛒᛡᛗ-ᛞᛈᚪᚳᛠᚷᛋ"

"ᛝᛏᛖᛒᛚᛉᚻ-ᚱᚩᚫᛇᛈᛄᛠ" &lt;
"ᛋᛄᛚᚪᛄᚱᛏ-ᛞᚷᚫᛠᚠᛉᛞ"
"ᚫᛏᛖᚢᛝᚫᛡ-ᚾᛁᛠᚻᚦᚣᛠ" &lt;

@ MAYFLY

"ᛈᛟᚠ ᛈᚠᛝᚫᛝᛋ ᛟᛄᚹ"
"ᛈᛟᛝ ᛇᚦᚣᛏᚫᛉ ᛖᛟᛏ"

"ᚾᚳᚻᚹ-ᛇᛡᛈᛠᚹ"  &lt;
"ᚾᛉᛝᛗ-ᛖᚦᚢᛝᛡ" &lt;
"ᚾᛚᚹᛖ-ᚩᛚᛁᛄᛏ"   &lt;
"ᛠᛞᚣᛝ-ᚾᛁᚠᛈᛚ"
"ᛁᛠᚷᛚ-ᚷᚳᛋᚩᛝ"
"ᚾᛞᛝᚻ-ᛈᛠᚻᛡᚢ" &lt;


@ SPIRAL BRANCHES

"ᚦᛞ ᛁᚫᚩᚾ ᛋᚷᛈᚪᛖᚩ ᚣᚦᚹ ᚾᚷ"
"ᚻᛠ ᛞᚩᛄᚷ ᛋᚩᛠᚳᛖᛋ ᚣᛖᚫ ᛈᚦ"

"ᚩᛚᛞ ᛚᚹᚳᛄᚹᛉ ᚪᛡᚹᛇ ᛖᛖᚹ ᛏᚪ"
"ᛖᛋᛞ ᛚᚳᛒᛞᛏᛈ ᛖᚾᛈᚣ ᚱᚠᚻ ᚫᛝ"

"ᛟᚳᛚᛞᛡᛚ ᚩᚳᛝᚢ ᛈᚹᛏ" &lt;
"ᛟᚪᛒᛁᛁᛋ ᛇᚷᚻᛋ ᛇᛡᛒ" &lt;
"ᛟᛟᚳᛏᛄᛞ ᛉᚾᛗᚦ ᛁᛄᚱ" &lt;
"ᛚᚹᚳᛄᚹᛉ ᚪᛡᚹᛇ ᛖᛖᚹ"   &lt;&lt;
"ᛚᚳᛒᛞᛏᛈ ᛖᚾᛈᚣ ᚱᚠᚻ"  &lt;&lt;
"ᚠᛚᛟᛝᚦᛠ ᚦᚣᛖᚣ ᚾᚷᚾ"

"ᛉᛉᛗᚾᚫᛋ ᚱᛗᛞᛋᚳ ᚦᛚᛟ" &lt; (a small match, but also a doublet in the 
same place)
"ᚹᚹᛟᚩᛒᚩ ᚾᚩᛄᛟᚾ ᚦᛡᚠ"  &lt;
"ᚩᛄᛞᚦᛏᛁ ᛈᚾᚪᚱᛄ ᛉᚱᚣ"
"ᛟᚻᛇᚾᛈᛏ ᛠᚣᛒᚢᚷ ᚷᚪᛇ"</code></pre>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>